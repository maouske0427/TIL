"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.init = void 0;
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const init = async () => {
    const rootDir = process.cwd();
    const workflowsDirectoryPath = node_path_1.default.join(rootDir, ".github/workflows");
    const publishWorkflowFilePath = node_path_1.default.join(workflowsDirectoryPath, "publish.yml");
    const publishWorkflowFileContent = `# Please set 'QIITA_TOKEN' secret to your repository
name: Publish articles

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: \${{ github.workflow }}-\${{ github.ref }}
  cancel-in-progress: false

jobs:
  publish_articles:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - uses: increments/qiita-cli/actions/publish@v0
        with:
          qiita-token: \${{ secrets.QIITA_TOKEN }}
`;
    if (!node_fs_1.default.existsSync(workflowsDirectoryPath)) {
        node_fs_1.default.mkdirSync(workflowsDirectoryPath, { recursive: true });
    }
    writeFile(publishWorkflowFilePath, publishWorkflowFileContent);
    const gitignoreFilePath = node_path_1.default.join(rootDir, ".gitignore");
    const gitignoreFileContent = `.remote
node_modules
`;
    writeFile(gitignoreFilePath, gitignoreFileContent);
};
exports.init = init;
const writeFile = (path, content) => {
    if (!node_fs_1.default.existsSync(path)) {
        node_fs_1.default.writeFile(path, content, { encoding: "utf8" }, (err) => {
            if (err)
                throw err;
            console.log(`Create ${path}`);
        });
    }
    else {
        console.log(`${path} is already exist`);
    }
};
//# sourceMappingURL=init.js.map
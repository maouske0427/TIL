"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QiitaApi = void 0;
const node_url_1 = require("node:url");
const debugger_1 = require("./lib/debugger");
class QiitaApi {
    constructor({ token }) {
        this.token = token;
    }
    getUrlScheme() {
        return "https";
    }
    getDomainName() {
        return process.env.QIITA_DOMAIN ? process.env.QIITA_DOMAIN : "qiita.com";
    }
    getBaseUrl() {
        const hostname = this.getDomainName();
        return `${this.getUrlScheme()}://${hostname}/`;
    }
    getPreviewUrl() {
        return `${this.getUrlScheme()}://${this.getDomainName()}`;
    }
    async request(url, options) {
        let response;
        try {
            (0, debugger_1.qiitaApiDebugger)(`request to`, url, JSON.stringify(options));
            response = await fetch(url, {
                headers: {
                    Authorization: `Bearer ${this.token}`,
                    "Content-Type": "application/json",
                },
                ...options,
            });
        }
        catch (err) {
            console.error(err);
            throw new Error("NetworkError");
        }
        if (response.ok) {
            const body = await response.text();
            try {
                return JSON.parse(body);
            }
            catch {
                return body;
            }
        }
        if (debugger_1.qiitaApiDebugger.enabled) {
            const responseBody = await response.text();
            (0, debugger_1.qiitaApiDebugger)("request failed", JSON.stringify({
                status: response.status,
                responseBody,
            }));
        }
        switch (response.status) {
            case 400:
                throw new Error("QiitaBadRequestError");
            case 401:
                throw new Error("QiitaUnauthorizedError");
            case 403:
                throw new Error("QiitaForbiddenError");
            case 404:
                throw new Error("QiitaNotFoundError");
            case 429:
                throw new Error("QiitaRateLimitError");
            case 500:
                throw new Error("QiitaInternalServerError");
            default:
                throw new Error("QiitaUnknownError");
        }
    }
    generateApiUrl(path) {
        const baseUrl = path === "/api/preview" ? this.getPreviewUrl() : this.getBaseUrl();
        return new node_url_1.URL(path, baseUrl).toString();
    }
    async get(path, options) {
        const url = this.generateApiUrl(path);
        return await this.request(url, {
            ...options,
            method: "GET",
        });
    }
    async post(path, options) {
        const url = this.generateApiUrl(path);
        return await this.request(url, {
            ...options,
            method: "POST",
        });
    }
    async patch(path, options) {
        const url = this.generateApiUrl(path);
        return await this.request(url, {
            ...options,
            method: "PATCH",
        });
    }
    async authenticatedUser() {
        return await this.get("/api/v2/authenticated_user");
    }
    async authenticatedUserItems(page, per) {
        const params = new node_url_1.URLSearchParams();
        if (page !== undefined) {
            params.set("page", page.toString());
        }
        if (per !== undefined) {
            params.set("per_page", per.toString());
        }
        const path = `/api/v2/authenticated_user/items?${params}`;
        return await this.get(path);
    }
    async preview(rawBody) {
        const body = JSON.stringify({
            parser_type: "qiita_cli",
            raw_body: rawBody,
        });
        return await this.post("/api/preview", {
            body,
        });
    }
    async items(page, per, query) {
        const params = new node_url_1.URLSearchParams();
        if (page !== undefined) {
            params.set("page", page.toString());
        }
        if (per !== undefined) {
            params.set("per_page", per.toString());
        }
        if (query !== undefined) {
            params.set("query", query);
        }
        const path = `/api/v2/items?${params}`;
        return await this.get(path);
    }
    async postItem({ rawBody, tags, title, isPrivate, organizationUrlName, }) {
        const data = JSON.stringify({
            body: rawBody,
            title,
            tags: tags.map((name) => {
                return {
                    name,
                    versions: [],
                };
            }),
            private: isPrivate,
            organization_url_name: organizationUrlName,
        });
        const path = `/api/v2/items`;
        return await this.post(path, {
            body: data,
        });
    }
    async patchItem({ uuid, rawBody, title, tags, isPrivate, organizationUrlName, }) {
        const data = JSON.stringify({
            body: rawBody,
            title,
            tags: tags.map((name) => {
                return {
                    name,
                    versions: [],
                };
            }),
            private: isPrivate,
            organization_url_name: organizationUrlName,
        });
        const path = `/api/v2/items/${uuid}`;
        return await this.patch(path, {
            body: data,
        });
    }
}
exports.QiitaApi = QiitaApi;
//# sourceMappingURL=index.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.config = void 0;
const promises_1 = __importDefault(require("node:fs/promises"));
const node_os_1 = __importDefault(require("node:os"));
const node_path_1 = __importDefault(require("node:path"));
const node_process_1 = __importDefault(require("node:process"));
const debugger_1 = require("./debugger");
class Config {
    constructor() { }
    load(options) {
        this.configDir = this.resolveConfigDir(options.configDir);
        this.itemsRootDir = this.resolveItemsRootDir(options.itemsRootDir);
        this.credential = new Credential({
            credentialDir: this.configDir,
            profile: options.profile,
        });
        (0, debugger_1.configDebugger)("load", JSON.stringify({
            configDir: this.configDir,
            itemsRootDir: this.itemsRootDir,
        }));
    }
    getConfigDir() {
        if (!this.configDir) {
            throw new Error("configDir is undefined");
        }
        return this.configDir;
    }
    // TODO: filesystemrepo 側にあるべきか確認
    getItemsRootDir() {
        if (!this.itemsRootDir) {
            throw new Error("itemsRootDir is undefined");
        }
        return this.itemsRootDir;
    }
    getCredential() {
        if (!this.credential) {
            throw new Error("credential is undefined");
        }
        return this.credential.getCredential();
    }
    setCredential(credential) {
        if (!this.credential) {
            throw new Error("credential is undefined");
        }
        return this.credential.setCredential(credential);
    }
    resolveConfigDir(configDirPath) {
        const packageName = "qiita-cli";
        if (node_process_1.default.env.XDG_CONFIG_HOME) {
            const configDir = node_process_1.default.env.XDG_CONFIG_HOME;
            return node_path_1.default.join(configDir, packageName);
        }
        if (!configDirPath) {
            const homeDir = node_os_1.default.homedir();
            return node_path_1.default.join(homeDir, ".config", packageName);
        }
        return this.resolveFullPath(configDirPath);
    }
    resolveItemsRootDir(dirPath) {
        if (node_process_1.default.env.QIITA_CLI_ITEMS_ROOT) {
            return node_process_1.default.env.QIITA_CLI_ITEMS_ROOT;
        }
        if (!dirPath) {
            return node_process_1.default.cwd();
        }
        return this.resolveFullPath(dirPath);
    }
    resolveFullPath(filePath) {
        if (node_path_1.default.isAbsolute(filePath)) {
            return filePath;
        }
        else {
            return node_path_1.default.join(node_process_1.default.cwd(), filePath);
        }
    }
}
/**
 * credential file format example:
 *
 * {
 *   "default": "qiita",
 *   "credentials": [
 *     {
 *       "accessToken": "PUBLIC_ACCESS_TOKEN",
 *       "name": "qiita"
 *     },
 *   ]
 * }
 */
class Credential {
    constructor({ credentialDir, profile, }) {
        this.credentialFilePath = node_path_1.default.join(credentialDir, "credentials.json");
        this.credentialDir = credentialDir;
        this.currentProfile = profile;
        this.cache = null;
    }
    async load() {
        if (this.cache !== null) {
            return this.cache;
        }
        let credentialData;
        if (node_process_1.default.env.QIITA_TOKEN) {
            const name = "environment variable";
            credentialData = {
                default: name,
                credentials: [
                    {
                        accessToken: node_process_1.default.env.QIITA_TOKEN,
                        name,
                    },
                ],
            };
        }
        else {
            const data = await promises_1.default.readFile(this.credentialFilePath, {
                encoding: "utf8",
            });
            credentialData = JSON.parse(data);
        }
        this.cache = credentialData;
        return credentialData;
    }
    refresh() {
        this.cache = null;
    }
    async getCredential() {
        const credentialData = await this.load();
        const profile = this.currentProfile
            ? this.currentProfile
            : credentialData.default;
        const credential = credentialData.credentials.find((cred) => cred.name === profile);
        if (!credential) {
            console.error("CredentialError:");
            console.error(`  profile is not exists '${profile}'`);
            node_process_1.default.exit(1);
        }
        (0, debugger_1.configDebugger)("use credential", JSON.stringify({ ...credential, accessToken: "******" }));
        return credential;
    }
    async setCredential(credential) {
        let credentialData;
        try {
            credentialData = await this.load();
        }
        catch (err) {
            // Error is not `no such file or directory`
            if (err.code !== "ENOENT") {
                throw err;
            }
            await promises_1.default.mkdir(this.credentialDir, { recursive: true });
            credentialData = {
                default: credential.name,
                credentials: [],
            };
        }
        const newCredentialData = {
            default: credentialData.default,
            credentials: [
                ...credentialData.credentials.filter((cred) => cred.name !== credential.name),
                credential,
            ],
        };
        await promises_1.default.writeFile(this.credentialFilePath, JSON.stringify(newCredentialData, null, 2), { encoding: "utf8", mode: 0o600 });
        this.refresh();
    }
}
const config = new Config();
exports.config = config;
//# sourceMappingURL=config.js.map